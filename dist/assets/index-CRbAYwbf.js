import{r,g as a}from"./index-CwxirhWB.js";import{u as d}from"./index-BRTLPeh9.js";function b(t,o,{checkForDefaultPrevented:e=!0}={}){return function(n){if(t?.(n),e===!1||!n.defaultPrevented)return o?.(n)}}var R=a[" useId ".trim().toString()]||(()=>{}),E=0;function P(t){const[o,e]=r.useState(R());return d(()=>{e(s=>s??String(E++))},[t]),t||(o?`radix-${o}`:"")}var g=a[" useInsertionEffect ".trim().toString()]||d;function y({prop:t,defaultProp:o,onChange:e=()=>{},caller:s}){const[n,l,i]=S({defaultProp:o,onChange:e}),c=t!==void 0,v=c?t:n;{const u=r.useRef(t!==void 0);r.useEffect(()=>{const f=u.current;f!==c&&console.warn(`${s} is changing from ${f?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=c},[c,s])}const m=r.useCallback(u=>{if(c){const f=h(u)?u(t):u;f!==t&&i.current?.(f)}else l(u)},[c,t,l,i]);return[v,m]}function S({defaultProp:t,onChange:o}){const[e,s]=r.useState(t),n=r.useRef(e),l=r.useRef(o);return g(()=>{l.current=o},[o]),r.useEffect(()=>{n.current!==e&&(l.current?.(e),n.current=e)},[e,n]),[e,s,l]}function h(t){return typeof t=="function"}export{P as a,b as c,y as u};
